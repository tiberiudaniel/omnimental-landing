Acesta este un Master Spec pentru implementarea completÄƒ a Onboarding-ului ExperienÈ›ial.
si cateva specificatii despre scaffolding.

Scaffolding, pe scurt, este felul Ã®n care â€œÈ›ii de mÃ¢nÄƒâ€ omul exact atÃ¢t cÃ¢t are nevoie ca sÄƒ poatÄƒ progresa singur, pas cu pas, fÄƒrÄƒ sÄƒ-l copleÈ™eÈ™ti È™i fÄƒrÄƒ sÄƒ-l laÈ™i Ã®n aer.

Aplicat la OmniMental, scaffolding Ã®nseamnÄƒ:

sÄƒ nu arunci utilizatorul Ã®ntr-un â€œmega-ecosistemâ€ de teste È™i module,

ci sÄƒ-i dai o cale clarÄƒ, cu sprijin dozabil, care se retrage treptat pe mÄƒsurÄƒ ce capÄƒtÄƒ skill È™i autonomie.

1. DefiniÈ›ie (adaptatÄƒ pentru Omnimental)

Scaffolding = structura de sprijin temporar (design + conÈ›inut + mesaje) care:

Ã®l porneÈ™te pe user de la nivelul lui real (nu ideal),

Ã®i dÄƒ exact atÃ¢ta claritate, exemple È™i ghidare cÃ¢t sÄƒ reuÈ™eascÄƒ urmÄƒtorul pas,

reduce gradual suportul, astfel Ã®ncÃ¢t userul sÄƒ devinÄƒ capabil sÄƒ-È™i gestioneze singur antrenamentul mental.

Ãn OmniMental, â€œscheleleâ€ sunt: onboarding-ul, mini-teste, mesaje din typewriter, recomandÄƒri implicite, gating, XP, Omni-Kuno, Omni-Sensei, layout-ul dashboardului etc.

2. Principii de scaffolding pentru OmniMental

Un singur obiectiv clar pe â€œpasâ€

FÄƒrÄƒ ecrane Ã®n care userul are 4 decizii majore deodatÄƒ.

Fiecare pas rÄƒspunde la: â€œDe ce fac asta acum?â€ È™i â€œCe primesc imediat?â€

Pornim din limbajul lui, nu din modelul tÄƒu

Intent + Cloud â†’ selectezi automat cuvintele È™i dimensiunile lui (relaÈ›ii, calm, performanÈ›Äƒ etc).

Omni-Kuno Onboarding nu e generic, ci scaffolding personal: â€œacum, Ã®n relaÈ›iiâ€ / â€œacum, Ã®n focus È™i obosealÄƒâ€.

Un singur nivel de dificultate nou la un moment dat

Nu dai È™i concept nou, È™i exerciÈ›iu greu, È™i jurnal profund Ã®n acelaÈ™i ecran.

ÃntÃ¢i Ã®i dai un test uÈ™or + insight simplu; abia apoi exerciÈ›iu mai intens sau jurnal ghidat.

Feedback imediat, neutru, scurt

DupÄƒ fiecare mini-test, userul primeÈ™te 1â€“2 propoziÈ›ii care pun sens, nu judecatÄƒ.

Scaffolding-ul e feedback-ul care Ã®l orienteazÄƒ: â€œEÈ™ti pe hartÄƒ. Uite unde eÈ™ti È™i ce are sens sÄƒ faci urmÄƒtorul pas.â€

Fading (retragi treptat sprijinul)

La Ã®nceput: mesaje mai explicite, exemplu de jurnal, reminder clar.

DupÄƒ cÃ¢teva sesiuni: mai puÈ›inÄƒ explicaÈ›ie, mai multÄƒ autonomie (â€œalege tu modululâ€, â€œalege tu tema din jurnalâ€).

3. Sugestii concrete de scaffolding Ã®n proiectul OmniMental
3.1. Scaffolding Ã®n onboarding (wizard + Omni-Kuno)

Primul contact (Vreau sÄƒ testez OmniMental)

Ecranul de intro sÄƒ funcÈ›ioneze ca â€œscaffold de sensâ€:

explicaÈ›ie scurtÄƒ: ce e OmniMental, ce cÃ¢È™tigi Ã®n urmÄƒtoarele 5â€“10 minute;

timeline foarte minimal (3 paÈ™i: â€œTe clarifici â†’ Faci un mini-test â†’ Vezi primul tÄƒu progresâ€).

Intent + Cloud = scaffolding de limbaj

Cloud-ul de expresii este deja un scaffold: Ã®l ajuÈ›i sÄƒ numeascÄƒ ceva ce simÈ›ea, dar nu formula.

ÃmbunÄƒtÄƒÈ›ire:

dupÄƒ selectarea expresiilor, un micro-rezumat: â€œOk, te preocupÄƒ mai ales X È™i Y. Folosim asta Ã®n test È™i antrenament.â€

Omni-Kuno Mini-test = scaffolding de diagnostic blÃ¢nd

7â€“8 Ã®ntrebÄƒri: mix de knowledge + reflecÈ›ie + scenariu, toate Ã®n jurul categoriei lui.

La final: 2â€“3 propoziÈ›ii neutre + un singur â€œNext step recomandatâ€ (nu 4 opÈ›iuni).

LegÄƒtura cu dashboard

CÃ¢nd ajunge Ã®n /progress prima oarÄƒ, scaffolding-ul este layout + micro-text:

Ce vede â†’ Ce Ã®nseamnÄƒ â†’ Ce poate face mai departe (Ã®ntotdeauna o singurÄƒ sugestie clarÄƒ).

3.2. Scaffolding Ã®n Omni-Kuno (engine de educaÈ›ie È™i testare)

Niveluri de dificultate vizibile implicit, nu declarat

Lvl 1 = Ã®ntrebÄƒri simple, explicaÈ›ii mai multe Ã®n learn.

Lvl 2 = itemi mix knowledge + scenariu, exerciÈ›ii un pic mai provocatoare.

Lvl 3 = itemi de fineÈ›e, inversarea rolurilor, situaÈ›ii complexe.

Scaffold-ul e: nu-l laÈ™i sÄƒ sarÄƒ Ã®n lvl 3 fÄƒrÄƒ sÄƒ fi trecut de cÃ¢teva sesiuni la lvl 1â€“2.

â€œPacheteâ€ de learning gata definite

Pentru fiecare categorie (relaÈ›ii, calm, performanÈ›Äƒ):

Pachet 1 (Ã®ncepÄƒtor): mini-test + 1 lecÈ›ie + 1 exerciÈ›iu de viaÈ›Äƒ realÄƒ.

Pachet 2 (intermediar): practice adaptiv + jurnal ghidat.

Pachet 3 (avansat): challenge de 7 zile / micro-misiuni.

Userul nu navigheazÄƒ haotic; scaffolding-ul este: â€œTu eÈ™ti acum Ã®n Pachet 1 pentru RELAÈšII. Èši-au mai rÄƒmas 2 paÈ™i.â€

Micro-scaffolding Ã®n itemii Kuno

Ãn loc de Ã®ntrebÄƒri izolate, grupezi 2â€“3 itemi care se leagÄƒ Ã®ntre ei:

Q1: cum reacÈ›ionezi acum (scenariu).

Q2: ce spune cercetarea (knowledge).

Q3: ce ai putea testa ca mic experiment (microSkill).

E o mini-scarÄƒ Ã®n sine: stare actualÄƒ â†’ concept â†’ micro acÈ›iune.

3.3. Scaffolding Ã®n Training Zone / Omni-Sensei

Ghidare iniÈ›ialÄƒ foarte clarÄƒ

Prima datÄƒ cÃ¢nd intrÄƒ Ã®n Training:

un text scurt: â€œAici nu mai e testare, aici e antrenament. Ãncepem cu X È™i Y pentru cÄƒ asta a ieÈ™it Ã®n onboarding.â€

Sugerezi 1â€“2 â€œtrack-uriâ€ de antrenament, nu Ã®ntreg catalogul.

ConstrÃ¢ngeri pozitive (gating)

Nu laÈ™i userul sÄƒ Ã®nceapÄƒ 7 track-uri deodatÄƒ.

Scaffolding-ul e cÄƒ Ã®l limitezi la 1â€“2 focusuri active, dar Ã®i explici de ce:

â€œConcentrarea pe maximum 2 direcÈ›ii simultan creÈ™te È™ansa sÄƒ vezi progres real.â€

Fading deliberat

La Ã®nceput, Omni-Sensei explicÄƒ mai mult, face metafore, ghidaj.

DupÄƒ cÃ¢teva sesiuni bune È™i streak, mesajele devin mai scurte, mai provocatoare, mai autonome:

â€œAlege singur urmÄƒtorul exerciÈ›iu Ã®n funcÈ›ie de cum te simÈ›i azi.â€

3.4. Scaffolding prin gamification (fÄƒrÄƒ copilÄƒrisme)

Scaffolding = ritm + feedback.

XP + streak = scaffolding de ritm: Ã®l ajuÈ›i sÄƒ â€œvadÄƒâ€ cÄƒ e important sÄƒ revinÄƒ des, nu perfect.

Badge-uri = scaffolding de milestone: Ã®i arÄƒÈ›i clar unde au fost paÈ™i importanÈ›i (primul test, primul jurnal, 7 zile la rÃ¢nd etc.).

Mastery bars = scaffolding de hartÄƒ: Ã®l orientezi pe â€œhartÄƒ mentalÄƒâ€ (â€œsunt pe drumul Äƒsta la 40%, pe celÄƒlalt la 70%â€).

Important: gamification-ul nu e scop, e exoscheletul care È›ine laolaltÄƒ efortul È™i ritmul, pÃ¢nÄƒ Ã®È™i construieÈ™te autonom motivaÈ›ia.

3.5. Scaffolding pentru date È™i insight-uri (din perspectiva ta, ca coach)

Prin scaffolding inteligent, onboarding-ul devine:

un profil clar de punct de plecare,

un filtru: cine e curios/implicat vs cine doar â€œbifeazÄƒâ€,

un predictor: cine ajunge la un anumit nivel de mastery & streak are È™anse mai mari sÄƒ cumpere programe mai intense sau 1:1.

PoÈ›i seta de la Ã®nceput:

reguli: â€œnu deschidem Omni-Sensei avansat Ã®nainte de X Ã®n Kuno + Y Ã®n streakâ€,

semnale: â€œcine trece de 60% mastery la RelaÈ›ii + 30 zile streak este candidat bun pentru grup avansat / program premiumâ€.

Asta e scaffolding È™i la nivel de funnel de business, nu doar la nivel de UX.


ğŸ”¥ OMNIMENTAL â€” MASTER ONBOARDING SPEC
(versiunea completÄƒ pentru implementare Codex)
I. STRUCTURA FINALÄ‚ A FLUXULUI (USER JOURNEY)

0. Alege intenÈ›ia â†’ primeÈ™te recomandarea (deja implementat)
â†“
1. Intro experienÈ›ial (typewriter) â€” â€Vrei sÄƒ experimentezi OmniMental din interior?â€
â†“
2. Mini-Test Personalizat (OmniCuno) â€” tematic pe interesul userului
â†“
3. Verdict + Corect/Incorrect + ExplicaÈ›ie
â†“
4. Ecran Scor (typewriter: â€Acesta e primul tÄƒu progres.â€)
â†“
5. Mergi la /progress?from=onboarding-test
â†“
6. Dashboard highlight + mesaj: â€Ai cÃ¢È™tigat 10 puncte Ã®n OC.â€
â†“
7. ContinuÄƒ cu OmniScop â†’ Jurnal scurt
â†“
8. Salvezi jurnalul â†’ +10 puncte OS
â†“
9. Ãnapoi Ã®n Progress â†’ highlight OS
â†“
10. OmniAbil â€“ exerciÈ›iu respirator ghidat 2 min
â†“
11. Finalizare â†’ +15 puncte OA
â†“
12. Dashboard finalizat â†’ progres vizibil Ã®n 3 zone
â†“
13. Ecran final + ProiecÈ›ie Zile/SÄƒptÄƒmÃ¢ni/Luni
â†“
14. CTA final â†’ /antrenament

Acest flow Ã®l face pe user:

sÄƒ Ã®nveÈ›e

sÄƒ simtÄƒ

sÄƒ progreseze

sÄƒ se implice

sÄƒ vadÄƒ valoare realÄƒ

sÄƒ fie pregÄƒtit pentru sesiuni

II. STRUCTURA FOLDERELOR (FINALÄ‚)
/app
  /experience-onboarding
    page.tsx
    /steps
      StepIntro.tsx
      StepMiniTest.tsx
      StepMiniTestScore.tsx
      StepProgressRedirect.tsx
      StepJournal.tsx
      StepBreathPractice.tsx
      StepProjection.tsx

/components
  /onboarding
    Typewriter.tsx
    TestQuestionCard.tsx
    ScoreCard.tsx
    GuideCard.tsx
    BreathAnimation.tsx

/lib
  levels.ts
  engine.ts
  onboarding.ts
  cunoQuestions.ts

III. FILE SPECIFIC â€” TOT CE TREBUIE CODEx SÄ‚ IMPLEMENTEZE
âœ” 1. /app/experience-onboarding/page.tsx

Rol: router pentru toate etapele.

ConÈ›ine:
export default function ExperienceOnboarding() {
  const [step, setStep] = useState(0);

  return (
    <>
      {step === 0 && <StepIntro onNext={() => setStep(1)} />}
      {step === 1 && <StepMiniTest onNext={() => setStep(2)} />}
      {step === 2 && <StepMiniTestScore onNext={() => setStep(3)} />}
      {step === 3 && <StepProgressRedirect />}
      {step === 4 && <StepJournal onNext={() => setStep(5)} />}
      {step === 5 && <StepBreathPractice onNext={() => setStep(6)} />}
      {step === 6 && <StepProjection />}
    </>
  );
}


CHECKPOINT:
Flow router funcÈ›ional, fÄƒrÄƒ redirecÈ›ionÄƒri premature.

âœ” 2. components/onboarding/Typewriter.tsx

Rol: motor comun pentru mesaje.

CerinÈ›e:

vitezÄƒ variabilÄƒ: 20â€“40ms/char

pauze controlate (await new Promise)

stil vorbire umanÄƒ: mici pauze Ã®ntre fraze

fallback instant pe mobil dacÄƒ utilizatorul atinge ecranul

âœ” 3. /app/experience-onboarding/steps/StepIntro.tsx

Typewriter + buton.

Mesaj:

â€Ãnainte sÄƒ Ã®ncepi, vreau sÄƒ simÈ›i ce Ã®nseamnÄƒ antrenamentul mental.
ImagineazÄƒ-È›i cÄƒ intri pentru prima datÄƒ Ã®ntr-un dojo al minÈ›ii...
EÈ™ti pregÄƒtit sÄƒ testezi cum funcÈ›ioneazÄƒ OmniMental din interior?â€

Button: â€Da, vreau sÄƒ Ã®ncepâ€

âœ” 4. /steps/StepMiniTest.tsx

Mini test format MCQ + rÄƒspuns corect/greÈ™it.

CerinÈ›e tehnice:

Ã®ntrebare + 4 variante

la selectare:

afiÈ™ezi â€Corect / Incorrectâ€

explici varianta corectÄƒ

dupÄƒ 3â€“5 Ã®ntrebÄƒri:

calculezi scor

salvezi Ã®n Firestore:

/cunoTests/{uid}/initialTest
  - score
  - correct
  - incorrect
  - timestamp


adaugi XP: updateLevel(uid, "focus"/"sleep"/"calm", 10)

âœ” 5. /steps/StepMiniTestScore.tsx

Typewriter:

â€Acesta este primul tÄƒu progres.
Ai obÈ›inut X/X.â€

Button â†’ /progress?from=onboarding-test

âœ” 6. /steps/StepProgressRedirect.tsx

Se foloseÈ™te router:

router.replace("/progress?from=guide-1");


CHECKPOINT: Ã®n progress se activeazÄƒ highlight-ul.

âœ” 7. /steps/StepJournal.tsx

Ecran de OmniScop (OS) simplificat:

Comportament:

text prompt: â€Scrie o frazÄƒ care te reprezintÄƒ acum.â€

textarea

onSubmit:

salveazÄƒ Ã®n Firestore /journal

updateLevel(uid, "os", 10)

Button: â€ContinuÄƒâ€

âœ” 8. /steps/StepBreathPractice.tsx

2 minute respiraÈ›ie ghidatÄƒ.

CerinÈ›e:

componentÄƒ BreathAnimation (puls / cerc)

timer

la final: updateLevel(uid, "oa", 15)

text scurt: â€Excelent. Ai antrenat un reflex vital.â€

âœ” 9. /steps/StepProjection.tsx

ProiecÈ›ie finalÄƒ:

ConÈ›inut:

â€Ãn cÃ¢teva zileâ€¦â€ + mini-grafice statice

â€Ãn cÃ¢teva sÄƒptÄƒmÃ¢niâ€¦â€

â€Ãn cÃ¢teva luniâ€¦â€

CTA: â€Ãncepe antrenamentul completâ€ â†’ /antrenament

IV. LIB MODULES â€” TOT CE ESTE NECESAR
âœ” lib/levels.ts

â€“ XP + logicÄƒ de progres
â€“ decay pasiv
â€“ updateLevel()

(Ai deja versiunea completÄƒ.)

âœ” lib/engine.ts

â€“ next recommended step
â€“ triggers OmniSensei

âœ” lib/onboarding.ts

Codex trebuie sÄƒ creeze:
funcÈ›ii utilitare:

export function getUserMainIntent(profileFacts) {}
export function getMiniTestForIntent(intent) {}
export function recordOnboardingEvent(uid, step) {}


Simplu, doar pentru routing logic.

âœ” lib/cunoQuestions.ts

Set structurat:

{
  sleep: [...],
  focus: [...],
  calm: [...],
  identity: [...],
  performance: [...]
}


Fiecare Ã®ntrebare:

{
  q: "...",
  options: ["...", "...", "...", "..."],
  correct: 2,
  explanation: "..."
}

V. CHECKPOINTS PENTRU CODEX
ğŸ”µ Check 1 â€” Flow router

ExperienceOnboarding/page.tsx trebuie sÄƒ treacÄƒ prin TOATE etapele, fÄƒrÄƒ skip.

ğŸ”µ Check 2 â€” Typewriter

vitezÄƒ 20â€“40ms

pauze Ã®ntre fraze

click = skip to end

ğŸ”µ Check 3 â€” MiniTest

scor corect

feedback corect/incorrect

explicatii

XP + Firestore

ğŸ”µ Check 4 â€” Progress redirect

/progress?from=onboarding-test afiÈ™eazÄƒ highlight.

ğŸ”µ Check 5 â€” Jurnal â†’ XP
ğŸ”µ Check 6 â€” RespiraÈ›ie â†’ XP
ğŸ”µ Check 7 â€” Projection final â†’ CTA
VI. OPTIMIZARE TYPEWRITER (VEL REALIST)

Ãn Typewriter.tsx:

timpul Ã®ntre caractere:

const speed = Math.random() * (40 - 20) + 20;


pauzÄƒ Ã®ntre propoziÈ›ii:
dacÄƒ detectezi .:

await new Promise(res => setTimeout(res, 200));


dacÄƒ userul face click:
scrie instant tot textul.

VII. MESAJ FINAL (FOARTE IMPORTANT)

Da â€” acesta este onboarding-ul corect pentru OmniMental:

fluid,

narativ,

progresiv,

experienÈ›ial,

recompensator,

inteligent,

ghidat,

cu XP real,

cu bucle reale,

cu intrarea Ã®n OS, OC, OA din primele minute,

cu dashboard viu,

cu proiecÈ›ie finalÄƒ.

Codex are acum TOT ce Ã®i trebuie pentru a implementa acest flow fÄƒrÄƒ confuzii.


ÃÈ›i dau direct codul, fiÈ™ier cu fiÈ™ier, Ã®n ordinea optimÄƒ.
PoÈ›i copia-paste Ã®n proiect È™i lÄƒsa Codex sÄƒ ajusteze micile detalii (ex: hook-ul real de user).

1. app/experience-onboarding/page.tsx
"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import StepIntro from "./steps/StepIntro";
import StepMiniTest from "./steps/StepMiniTest";
import StepMiniTestScore from "./steps/StepMiniTestScore";
import StepProgressRedirect from "./steps/StepProgressRedirect";
import StepJournal from "./steps/StepJournal";
import StepBreathPractice from "./steps/StepBreathPractice";
import StepProjection from "./steps/StepProjection";

// TODO: Ã®nlocuieÈ™te cu hook-ul real de user din proiect (ex: useAuth, useCurrentUser etc.)
function useUserId(): string | null {
  // exemplu placeholder
  return null;
}

export default function ExperienceOnboardingPage() {
  const [step, setStep] = useState(0);
  const [score, setScore] = useState<{ correct: number; total: number }>({
    correct: 0,
    total: 0,
  });
  const router = useRouter();
  const searchParams = useSearchParams();
  const userId = useUserId();

  useEffect(() => {
    // DacÄƒ vine din recommendation cu ?start=true, porneÈ™te direct flow-ul
    const start = searchParams.get("start");
    if (start === "1") {
      setStep(0);
    }
  }, [searchParams]);

  const handleFinishAndGoToProgress = () => {
    router.push("/progress?from=experience-onboarding");
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center px-4 py-8">
      {step === 0 && (
        <StepIntro
          onNext={() => setStep(1)}
        />
      )}

      {step === 1 && (
        <StepMiniTest
          userId={userId}
          onComplete={(result) => {
            setScore(result);
            setStep(2);
          }}
        />
      )}

      {step === 2 && (
        <StepMiniTestScore
          score={score}
          onNext={() => setStep(3)}
        />
      )}

      {step === 3 && (
        <StepProgressRedirect
          onNext={() => setStep(4)}
        />
      )}

      {step === 4 && (
        <StepJournal
          userId={userId}
          onNext={() => setStep(5)}
        />
      )}

      {step === 5 && (
        <StepBreathPractice
          userId={userId}
          onNext={() => setStep(6)}
        />
      )}

      {step === 6 && (
        <StepProjection onFinish={handleFinishAndGoToProgress} />
      )}
    </div>
  );
}

2. components/onboarding/Typewriter.tsx

Typewriter generic, cu viteza â€umanÄƒâ€ È™i skip la click/tap.

"use client";

import { useEffect, useState } from "react";

interface TypewriterProps {
  text: string;
  onFinished?: () => void;
  className?: string;
}

export default function Typewriter({
  text,
  onFinished,
  className,
}: TypewriterProps) {
  const [displayText, setDisplayText] = useState("");
  const [done, setDone] = useState(false);

  useEffect(() => {
    let i = 0;
    let cancelled = false;

    async function run() {
      while (i < text.length && !cancelled) {
        const char = text[i];
        setDisplayText(text.slice(0, i + 1));
        i++;

        // vitezÄƒ variabilÄƒ ca un vorbitor uman
        let baseDelay = Math.random() * (45 - 25) + 25;

        if (char === "." || char === "!" || char === "?") {
          baseDelay += 160;
        }
        if (char === "," || char === ";") {
          baseDelay += 80;
        }

        await new Promise((res) => setTimeout(res, baseDelay));
      }

      if (!cancelled) {
        setDone(true);
        onFinished?.();
      }
    }

    run();

    return () => {
      cancelled = true;
    };
  }, [text, onFinished]);

  const handleSkip = () => {
    if (!done) {
      setDisplayText(text);
      setDone(true);
      onFinished?.();
    }
  };

  return (
    <p
      className={className ?? "text-lg md:text-xl text-gray-700 leading-relaxed"}
      onClick={handleSkip}
    >
      {displayText}
      {!done && <span className="animate-pulse">â–Œ</span>}
    </p>
  );
}

3. components/onboarding/TestQuestionCard.tsx

Card de Ã®ntrebare cu 4 opÈ›iuni È™i feedback corect/greÈ™it.

"use client";

import { useState } from "react";

interface Question {
  id: string;
  q: string;
  options: string[];
  correct: number; // index Ã®n options
  explanation: string;
}

interface TestQuestionCardProps {
  question: Question;
  onAnswered: (isCorrect: boolean) => void;
}

export default function TestQuestionCard({
  question,
  onAnswered,
}: TestQuestionCardProps) {
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);
  const [showResult, setShowResult] = useState(false);

  const handleSelect = (index: number) => {
    if (showResult) return;
    setSelectedIndex(index);
    const isCorrect = index === question.correct;
    setShowResult(true);
    onAnswered(isCorrect);
  };

  const isCorrectSelection =
    showResult && selectedIndex !== null && selectedIndex === question.correct;

  return (
    <div className="w-full max-w-xl mx-auto border rounded-2xl bg-white shadow-sm p-6">
      <h3 className="text-lg font-semibold mb-4 text-gray-900">
        {question.q}
      </h3>
      <div className="flex flex-col gap-2 mb-4">
        {question.options.map((opt, idx) => {
          const isSelected = selectedIndex === idx;
          const isCorrect = question.correct === idx;
          const baseClasses =
            "w-full text-left px-4 py-2 rounded-xl border transition-all text-sm";

          let extraClasses = "bg-white border-gray-300 hover:bg-gray-50";
          if (showResult) {
            if (isCorrect) {
              extraClasses = "border-emerald-500 bg-emerald-50 text-emerald-800";
            } else if (isSelected && !isCorrect) {
              extraClasses = "border-rose-500 bg-rose-50 text-rose-800";
            }
          } else if (isSelected) {
            extraClasses = "border-indigo-600 bg-indigo-50 text-indigo-800";
          }

          return (
            <button
              key={idx}
              type="button"
              onClick={() => handleSelect(idx)}
              className={`${baseClasses} ${extraClasses}`}
            >
              {opt}
            </button>
          );
        })}
      </div>

      {showResult && (
        <div
          className={`mt-3 text-sm rounded-xl px-4 py-3 ${
            isCorrectSelection
              ? "bg-emerald-50 text-emerald-800 border border-emerald-200"
              : "bg-amber-50 text-amber-800 border border-amber-200"
          }`}
        >
          <p className="font-semibold mb-1">
            {isCorrectSelection ? "Corect." : "Nu e varianta optimÄƒ."}
          </p>
          <p>{question.explanation}</p>
        </div>
      )}
    </div>
  );
}

4. components/onboarding/ScoreCard.tsx

Card scor dupÄƒ mini-test.

"use client";

interface ScoreCardProps {
  correct: number;
  total: number;
}

export default function ScoreCard({ correct, total }: ScoreCardProps) {
  const percent = total > 0 ? Math.round((correct / total) * 100) : 0;

  return (
    <div className="w-full max-w-md mx-auto border rounded-2xl bg-white shadow-sm p-6 text-center">
      <h3 className="text-xl font-semibold mb-2 text-gray-900">
        Primul tÄƒu scor Ã®n OmniCuno
      </h3>
      <p className="text-3xl font-bold text-indigo-700 mb-1">
        {correct}/{total}
      </p>
      <p className="text-sm text-gray-600 mb-3">
        ({percent}% rÄƒspunsuri corecte)
      </p>
      <p className="text-sm text-gray-600">
        Acesta este un punct de plecare. De aici Ã®ncolo, fiecare exerciÈ›iu È™i
        fiecare reflecÈ›ie Ã®È›i vor creÈ™te scorurile È™i claritatea.
      </p>
    </div>
  );
}


5. components/onboarding/GuideCard.tsx

Card de ghidare Ã®ntre paÈ™i.

"use client";

interface GuideCardProps {
  title: string;
  description: string;
  children?: React.ReactNode;
}

export default function GuideCard({
  title,
  description,
  children,
}: GuideCardProps) {
  return (
    <div className="w-full max-w-xl mx-auto bg-indigo-50 border border-indigo-100 rounded-2xl p-5 mb-4">
      <h4 className="text-base font-semibold text-indigo-900 mb-1">
        {title}
      </h4>
      <p className="text-sm text-indigo-800 mb-2">{description}</p>
      {children}
    </div>
  );
}

6. components/onboarding/BreathAnimation.tsx

AnimaÈ›ie respiraÈ›ie simplÄƒ.

"use client";

import { motion } from "framer-motion";

interface BreathAnimationProps {
  cueText?: string;
}

export default function BreathAnimation({
  cueText = "InspirÄƒ... expirÄƒ...",
}: BreathAnimationProps) {
  return (
    <div className="flex flex-col items-center justify-center gap-4">
      <motion.div
        className="w-32 h-32 rounded-full border-4 border-indigo-300"
        animate={{ scale: [1, 1.3, 1] }}
        transition={{
          duration: 6,
          repeat: Infinity,
          ease: "easeInOut",
        }}
      />
      <p className="text-sm text-gray-700">{cueText}</p>
      <p className="text-xs text-gray-500">
        UrmeazÄƒ ritmul cercului. LasÄƒ corpul sÄƒ se liniÈ™teascÄƒ.
      </p>
    </div>
  );
}

7. lib/cunoQuestions.ts

ÃntrebÄƒri tematice de exemplu (Codex poate extinde).

export type CunoArea = "sleep" | "focus" | "calm" | "time" | "identity";

export interface CunoQuestion {
  id: string;
  q: string;
  options: string[];
  correct: number;
  explanation: string;
}

type CunoQuestionSet = {
  [area in CunoArea]: CunoQuestion[];
};

export const CUNO_QUESTIONS: CunoQuestionSet = {
  sleep: [
    {
      id: "sleep-1",
      q: "Care dintre urmÄƒtoarele obiceiuri ajutÄƒ cel mai mult calitatea somnului?",
      options: [
        "Scroll pe telefon pÃ¢nÄƒ adormi",
        "Cafea tare cu 2 ore Ã®nainte de somn",
        "O rutinÄƒ constantÄƒ de culcare, la ore similare",
        "Mese foarte bogate chiar Ã®nainte de culcare",
      ],
      correct: 2,
      explanation:
        "Ritmul constant de culcare trezeÈ™te sistemul nervos Ã®n acelaÈ™i interval È™i ajutÄƒ creierul sÄƒ intre mai uÈ™or Ã®n somn profund.",
    },
    {
      id: "sleep-2",
      q: "Ce efect are lumina albastrÄƒ puternicÄƒ seara?",
      options: [
        "AccelereazÄƒ adormirea",
        "Scade secreÈ›ia de melatoninÄƒ È™i Ã®ntÃ¢rzie somnul",
        "Nu are niciun efect",
        "Te face sÄƒ visezi mai intens",
      ],
      correct: 1,
      explanation:
        "Lumina albastrÄƒ pÄƒcÄƒleÈ™te creierul cÄƒ Ã®ncÄƒ este zi, scade melatonina È™i Ã®ntÃ¢rzie adormirea.",
    },
  ],
  focus: [
    {
      id: "focus-1",
      q: "Ce ajutÄƒ cel mai mult concentrarea Ã®ntr-o sesiune de lucru?",
      options: [
        "SÄƒ sari constant Ã®ntre task-uri",
        "SÄƒ ai notificÄƒrile deschise la toate aplicaÈ›iile",
        "SÄƒ lucrezi Ã®n blocuri de timp clare, cu pauze scurte",
        "SÄƒ rÄƒspunzi imediat la orice mesaj primeÈ™ti",
      ],
      correct: 2,
      explanation:
        "Blocurile de timp clare (Pomodoro, deep work) reduc comutarea atenÈ›iei È™i cresc calitatea focusului.",
    },
  ],
  calm: [
    {
      id: "calm-1",
      q: "Ce semnal Ã®i transmite creierului o expiraÈ›ie lentÄƒ È™i prelungÄƒ?",
      options: [
        "CÄƒ trebuie sÄƒ creascÄƒ ritmul cardiac",
        "CÄƒ este Ã®n pericol",
        "CÄƒ poate sÄƒ intre Ã®n mod de siguranÈ›Äƒ È™i restabilire",
        "Nu are nicio legÄƒturÄƒ",
      ],
      correct: 2,
      explanation:
        "ExpiraÈ›iile lente activeazÄƒ ramura parasimpaticÄƒ a sistemului nervos, asociatÄƒ cu relaxarea È™i refacerea.",
    },
  ],
  time: [
    {
      id: "time-1",
      q: "Care este un prim pas eficient pentru managementul timpului?",
      options: [
        "SÄƒ Ã®ncerci sÄƒ faci cÃ¢t mai multe lucruri simultan",
        "SÄƒ-È›i clarifici 1â€“3 prioritÄƒÈ›i reale pentru ziua respectivÄƒ",
        "SÄƒ rÄƒspunzi la toate mesajele Ã®nainte sÄƒ Ã®ncepi ceva",
        "SÄƒ lucrezi fÄƒrÄƒ pauze pÃ¢nÄƒ eÈ™ti epuizat",
      ],
      correct: 1,
      explanation:
        "Clarificarea prioritÄƒÈ›ilor reduce haosul È™i te ajutÄƒ sÄƒ-È›i foloseÈ™ti energia pe ceea ce conteazÄƒ cu adevÄƒrat.",
    },
  ],
  identity: [
    {
      id: "id-1",
      q: "Ce defineÈ™te cel mai mult identitatea ta psihologicÄƒ, pe termen lung?",
      options: [
        "Un singur eÈ™ec major",
        "O singurÄƒ reuÈ™itÄƒ spectaculoasÄƒ",
        "Modelele de acÈ›iuni È™i decizii repetate Ã®n timp",
        "Ce cred alÈ›ii despre tine pe moment",
      ],
      correct: 2,
      explanation:
        "Identitatea psihologicÄƒ se construieÈ™te din tiparele de comportament È™i deciziile repetate, nu dintr-un singur moment.",
    },
  ],
};

8. app/experience-onboarding/steps/StepIntro.tsx
"use client";

import Typewriter from "@/components/onboarding/Typewriter";
import { Button } from "@/components/ui/button";
import GuideCard from "@/components/onboarding/GuideCard";

interface StepIntroProps {
  onNext: () => void;
}

export default function StepIntro({ onNext }: StepIntroProps) {
  const introText =
    "Ãnainte sÄƒ Ã®ncepi, hai sÄƒ simÈ›i cum ar putea arÄƒta antrenamentul tÄƒu mental.\n" +
    "ImagineazÄƒ-È›i cÄƒ intri pentru prima datÄƒ Ã®ntr-un spaÈ›iu de antrenament al minÈ›ii.\n" +
    "Aici testezi, Ã®nveÈ›i, respiri altfel È™i vezi cum se schimbÄƒ ceva Ã®n tine, pas cu pas.";

  return (
    <div className="w-full max-w-2xl mx-auto text-center space-y-8">
      <Typewriter
        text={introText}
        className="text-lg md:text-xl text-gray-800 leading-relaxed whitespace-pre-line"
      />
      <GuideCard
        title="Ce urmeazÄƒ"
        description="Ãn cÃ¢teva minute vei parcurge un test scurt, un exerciÈ›iu de reflecÈ›ie È™i un exerciÈ›iu de respiraÈ›ie. La final vei vedea cum aratÄƒ progresul tÄƒu Ã®ntr-un dashboard real."
      />
      <Button onClick={onNext} className="px-8 py-3 text-base">
        Da, vreau sÄƒ Ã®ncep
      </Button>
    </div>
  );
}


9. app/experience-onboarding/steps/StepMiniTest.tsx
"use client";

import { useEffect, useState } from "react";
import { doc, setDoc, serverTimestamp } from "firebase/firestore";
import { db } from "@/lib/firebase";
import { CUNO_QUESTIONS, CunoArea, CunoQuestion } from "@/lib/cunoQuestions";
import TestQuestionCard from "@/components/onboarding/TestQuestionCard";
import GuideCard from "@/components/onboarding/GuideCard";
import Typewriter from "@/components/onboarding/Typewriter";
// import { updateLevel } from "@/lib/levels"; // dacÄƒ foloseÈ™ti XP

interface StepMiniTestProps {
  userId: string | null;
  onComplete: (result: { correct: number; total: number }) => void;
}

export default function StepMiniTest({ userId, onComplete }: StepMiniTestProps) {
  const [area, setArea] = useState<CunoArea>("focus");
  const [questions, setQuestions] = useState<CunoQuestion[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [correctCount, setCorrectCount] = useState(0);

  useEffect(() => {
    // TODO: opÈ›ional â€“ obÈ›ine area din intentul userului (din progressFacts / recommendation)
    const chosenArea: CunoArea = "focus";
    setArea(chosenArea);
    setQuestions(CUNO_QUESTIONS[chosenArea].slice(0, 3)); // max 3 Ã®ntrebÄƒri
  }, []);

  const handleAnswered = (isCorrect: boolean) => {
    if (isCorrect) setCorrectCount((c) => c + 1);

    setTimeout(() => {
      if (currentIndex < questions.length - 1) {
        setCurrentIndex((idx) => idx + 1);
      } else {
        const result = {
          correct: correctCount + (isCorrect ? 1 : 0),
          total: questions.length,
        };
        saveResult(result);
      }
    }, 900);
  };

  const saveResult = async (result: { correct: number; total: number }) => {
    if (userId) {
      const ref = doc(db, "cunoTests", userId);
      await setDoc(
        ref,
        {
          initialTest: {
            area,
            ...result,
            timestamp: serverTimestamp(),
          },
        },
        { merge: true }
      );

      // XP (opÈ›ional)
      // await updateLevel(userId, area, 10);
    }

    onComplete(result);
  };

  if (!questions.length) {
    return (
      <div className="w-full max-w-xl mx-auto text-center">
        <p>Se pregÄƒteÈ™te testul...</p>
      </div>
    );
  }

  const currentQuestion = questions[currentIndex];

  return (
    <div className="w-full max-w-2xl mx-auto text-center space-y-6">
      <Typewriter
        text={`Ãncepem cu un test scurt, despre ${area}. Nu trebuie sÄƒ fie perfect. E doar un punct de plecare.`}
        className="text-base md:text-lg text-gray-700 leading-relaxed"
      />
      <GuideCard
        title="Cum funcÈ›ioneazÄƒ"
        description="RÄƒspunzi la cÃ¢teva Ã®ntrebÄƒri. Vei vedea imediat care era varianta optimÄƒ È™i de ce. La final, scorul tÄƒu intrÄƒ Ã®n dashboard."
      />
      <TestQuestionCard question={currentQuestion} onAnswered={handleAnswered} />
      <p className="text-xs text-gray-500">
        Ãntrebarea {currentIndex + 1} din {questions.length}
      </p>
    </div>
  );
}

10. app/experience-onboarding/steps/StepMiniTestScore.tsx
"use client";

import Typewriter from "@/components/onboarding/Typewriter";
import ScoreCard from "@/components/onboarding/ScoreCard";
import { Button } from "@/components/ui/button";

interface StepMiniTestScoreProps {
  score: { correct: number; total: number };
  onNext: () => void;
}

export default function StepMiniTestScore({
  score,
  onNext,
}: StepMiniTestScoreProps) {
  const text =
    "Acesta este primul tÄƒu scor Ã®n OmniCuno.\n" +
    "Nu este un verdict, ci o fotografie a punctului de plecare.\n" +
    "De aici, fiecare exerciÈ›iu È™i reflecÈ›ie va miÈ™ca aceste cifre.";

  return (
    <div className="w-full max-w-2xl mx-auto text-center space-y-8">
      <Typewriter
        text={text}
        className="text-base md:text-lg text-gray-800 leading-relaxed whitespace-pre-line"
      />
      <ScoreCard correct={score.correct} total={score.total} />
      <Button onClick={onNext} className="px-8 py-3 text-base">
        Vezi cum aratÄƒ Ã®n progres
      </Button>
    </div>
  );
}

11. app/experience-onboarding/steps/StepProgressRedirect.tsx
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import Typewriter from "@/components/onboarding/Typewriter";

interface StepProgressRedirectProps {
  onNext: () => void;
}

export default function StepProgressRedirect({
  onNext,
}: StepProgressRedirectProps) {
  const router = useRouter();

  useEffect(() => {
    const timeout = setTimeout(() => {
      router.push("/progress?from=onboarding-test");
      onNext();
    }, 2500);
    return () => clearTimeout(timeout);
  }, [router, onNext]);

  return (
    <div className="w-full max-w-2xl mx-auto text-center">
      <Typewriter
        text={
          "Te duc acum Ã®n zona de progres, ca sÄƒ vezi cum se Ã®nregistreazÄƒ acest test Ã®n tabloul tÄƒu de bord."
        }
        className="text-base md:text-lg text-gray-800 leading-relaxed"
      />
      <p className="text-xs text-gray-500 mt-4">
        DacÄƒ nu eÈ™ti redirecÈ›ionat automat, poÈ›i accesa din meniu secÈ›iunea
        Progres.
      </p>
    </div>
  );
}

12. app/experience-onboarding/steps/StepJournal.tsx
"use client";

import { useState } from "react";
import { doc, setDoc, serverTimestamp } from "firebase/firestore";
import { db } from "@/lib/firebase";
import Typewriter from "@/components/onboarding/Typewriter";
import { Button } from "@/components/ui/button";
import GuideCard from "@/components/onboarding/GuideCard";
// import { updateLevel } from "@/lib/levels"; // opÈ›ional

interface StepJournalProps {
  userId: string | null;
  onNext: () => void;
}

export default function StepJournal({ userId, onNext }: StepJournalProps) {
  const [text, setText] = useState("");
  const [saving, setSaving] = useState(false);

  const handleSave = async () => {
    if (!text.trim()) {
      onNext();
      return;
    }
    setSaving(true);
    try {
      if (userId) {
        const ref = doc(db, "journals", userId);
        await setDoc(
          ref,
          {
            entries: [
              {
                text,
                context: "onboarding",
                createdAt: serverTimestamp(),
              },
            ],
          },
          { merge: true }
        );
        // await updateLevel(userId, "os", 10);
      }
    } finally {
      setSaving(false);
      onNext();
    }
  };

  const intro =
    "Acum Ã®È›i propun un pas simplu de OmniScop.\n" +
    "Scrie o singurÄƒ frazÄƒ despre perioada Ã®n care eÈ™ti acum sau despre ce ai vrea sÄƒ se schimbe.";

  return (
    <div className="w-full max-w-2xl mx-auto space-y-6">
      <Typewriter
        text={intro}
        className="text-base md:text-lg text-gray-800 leading-relaxed whitespace-pre-line text-center"
      />
      <GuideCard
        title="Cum sÄƒ scrii"
        description="Nu cÄƒuta formularea perfectÄƒ. Scrie exact cum Ã®È›i vine. Important este sÄƒ pui Ã®n cuvinte ceva ce pÃ¢nÄƒ acum era doar Ã®n minte."
      />
      <textarea
        className="w-full border border-gray-300 rounded-xl p-3 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
        rows={4}
        placeholder="Scrie aici, Ã®n 1â€“2 propoziÈ›ii..."
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <div className="flex justify-center">
        <Button onClick={handleSave} disabled={saving} className="px-8 py-3">
          {saving ? "Se salveazÄƒ..." : "ContinuÄƒ"}
        </Button>
      </div>
    </div>
  );
}

13. app/experience-onboarding/steps/StepBreathPractice.tsx
"use client";

import { useEffect, useState } from "react";
import Typewriter from "@/components/onboarding/Typewriter";
import BreathAnimation from "@/components/onboarding/BreathAnimation";
// import { updateLevel } from "@/lib/levels";

interface StepBreathPracticeProps {
  userId: string | null;
  onNext: () => void;
}

export default function StepBreathPractice({
  userId,
  onNext,
}: StepBreathPracticeProps) {
  const [secondsLeft, setSecondsLeft] = useState(120); // 2 min
  const [finished, setFinished] = useState(false);

  useEffect(() => {
    if (secondsLeft <= 0) {
      setFinished(true);
      // dacÄƒ vrei XP aici:
      // if (userId) updateLevel(userId, "calm", 15);
      return;
    }
    const t = setTimeout(() => setSecondsLeft((s) => s - 1), 1000);
    return () => clearTimeout(t);
  }, [secondsLeft, userId]);

  const intro =
    "Acum Ã®È›i propun un exerciÈ›iu scurt de OmniAbil.\n" +
    "UrmÄƒreÈ™te cercul care se mÄƒreÈ™te È™i se micÈ™oreazÄƒ. InspirÄƒ cÃ¢nd se extinde, expirÄƒ cÃ¢nd revine.";

  return (
    <div className="w-full max-w-2xl mx-auto text-center space-y-6">
      <Typewriter
        text={intro}
        className="text-base md:text-lg text-gray-800 leading-relaxed whitespace-pre-line"
      />
      <BreathAnimation cueText="InspirÄƒ 4 secunde, expirÄƒ 6 secunde." />
      <p className="text-sm text-gray-600">
        Timp rÄƒmas: {Math.max(0, secondsLeft)} secunde
      </p>
      {finished && (
        <button
          onClick={onNext}
          className="mt-4 inline-flex items-center justify-center px-8 py-3 rounded-full bg-indigo-600 text-white text-sm font-medium hover:bg-indigo-700 transition-colors"
        >
          Am terminat. Merg mai departe.
        </button>
      )}
      {!finished && (
        <p className="text-xs text-gray-500">
          PoÈ›i Ã®ntrerupe mai devreme dacÄƒ simÈ›i nevoia. ExerciÈ›iul rÄƒmÃ¢ne Ã®n
          platformÄƒ È™i Ã®l vei putea relua.
        </p>
      )}
    </div>
  );
}


14. app/experience-onboarding/steps/StepProjection.tsx
"use client";

import Typewriter from "@/components/onboarding/Typewriter";
import { Button } from "@/components/ui/button";

interface StepProjectionProps {
  onFinish: () => void;
}

export default function StepProjection({ onFinish }: StepProjectionProps) {
  const text =
    "Ãn cÃ¢teva minute, ai fÄƒcut deja un test, ai scris Ã®n jurnal È™i ai trecut printr-un exerciÈ›iu de respiraÈ›ie.\n" +
    "ImagineazÄƒ-È›i cum ar arÄƒta lucrurile dacÄƒ ai repeta acest tip de antrenament cÃ¢teva zile, cÃ¢teva sÄƒptÄƒmÃ¢ni sau cÃ¢teva luni.";

  return (
    <div className="w-full max-w-2xl mx-auto text-center space-y-8">
      <Typewriter
        text={text}
        className="text-base md:text-lg text-gray-800 leading-relaxed whitespace-pre-line"
      />
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-left">
        <div className="border rounded-2xl p-4 bg-white shadow-sm">
          <h4 className="font-semibold text-gray-900 mb-2">
            Ãn cÃ¢teva zile
          </h4>
          <p className="text-sm text-gray-700">
            Ãncepi sÄƒ observi mici schimbÄƒri: respiraÈ›ia revine mai repede la
            calm, ai puÈ›in mai multÄƒ claritate È™i È™tii unde sÄƒ revii Ã®n
            platformÄƒ.
          </p>
        </div>
        <div className="border rounded-2xl p-4 bg-white shadow-sm">
          <h4 className="font-semibold text-gray-900 mb-2">
            Ãn cÃ¢teva sÄƒptÄƒmÃ¢ni
          </h4>
          <p className="text-sm text-gray-700">
            Se contureazÄƒ obiceiuri. Scorurile cresc, nivelul de reactivitate
            scade È™i Ã®ncepi sÄƒ simÈ›i cÄƒ ai un mediu real de antrenament mental.
          </p>
        </div>
        <div className="border rounded-2xl p-4 bg-white shadow-sm">
          <h4 className="font-semibold text-gray-900 mb-2">
            Ãn cÃ¢teva luni
          </h4>
          <p className="text-sm text-gray-700">
            Identitatea ta se schimbÄƒ. Nu mai este vorba doar despre a gestiona
            crize, ci despre a-È›i construi o structurÄƒ mentalÄƒ care susÈ›ine
            sÄƒnÄƒtate, performanÈ›Äƒ È™i relaÈ›ii mai bune.
          </p>
        </div>
      </div>

      <Button onClick={onFinish} className="px-8 py-3 text-base">
        Vreau sÄƒ intru Ã®n antrenamentul complet
      </Button>

      <p className="text-xs text-gray-500">
        Vei fi dus Ã®n zona principalÄƒ de antrenament, unde poÈ›i continua Ã®n
        ritmul tÄƒu, cu ghidaj È™i colegi de drum.
      </p>
    </div>
  );
}


Cu aceste fiÈ™iere, ai un set complet, coerent È™i implementabil direct.
Pasul urmÄƒtor pentru tine este doar sÄƒ decizi:


cum se obÈ›ine userId (sÄƒ Ã®nlocuiascÄƒ useUserId() cu hook-ul real)


dacÄƒ activezi imediat XP/levels (import updateLevel) sau Ã®l laÈ™i pentru etapa urmÄƒtoare.


