rules_version = '2';
service cloud.firestore {
  // DEV-optimized rules: keep it simple to validate the flow.
  // Important: tighten these before production (owner checks, field guards).
  match /databases/{database}/documents {

    function signedIn() { return request.auth != null; }
    function isOwner(uid) { return signedIn() && request.auth.uid == uid; }
    function adminEmail() {
      return (request.auth != null && request.auth.token.email != null) ? request.auth.token.email : "";
    }
    function flowStudioConfig() {
      return get(/databases/$(database)/documents/adminConfig/flowStudio).data;
    }
    function isFlowStudioAdmin() {
      return signedIn() &&
        flowStudioConfig().enabled == true &&
        flowStudioConfig().admins != null &&
        flowStudioConfig().admins.hasAny([adminEmail()]);
    }
    function isValidSessionType(v) { return v == null || v == 'individual' || v == 'group'; }
    function isValidSelection(v) { return v == null || v == 'none' || v == 'individual' || v == 'group'; }
    function isValidLang(lang) { return lang == 'ro' || lang == 'en'; }
    function hasTimestamp(field) { return field == null || field is timestamp; }
    function isValidJournal(text) { return text is string && text.size() > 0 && text.size() <= 1000; }

    // User profile remains owner-scoped even in dev.
    match /userProfiles/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create, update: if isOwner(userId);
    }

    // Progress facts attached to a user id.
    match /userProgressFacts/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create, update: if isOwner(userId) &&
        // If recommendation block is present, enforce allowed path values
        isValidSessionType(request.resource.data.recommendation.selectedPath) &&
        isValidSessionType(request.resource.data.recommendation.suggestedPath);
    }

    // Journals: owner-only, no extra field constraints
    match /userJournals/{userId} {
      allow read: if isOwner(userId);
      allow create, update: if isOwner(userId);

      match /entries/{entryId} {
        allow read, create: if isOwner(userId);
        allow update, delete: if isOwner(userId);
      }
    }

    // Snapshots and journeys: owner-only access. Allow create if profileId matches auth uid.
    // Accept either `evaluation` or legacy `answers`, and flexible timestamps.
    match /userIntentSnapshots/{docId} {
      allow create: if signedIn() &&
        request.resource.data.profileId == request.auth.uid &&
        isValidLang(request.resource.data.lang) &&
        hasTimestamp(request.resource.data.timestamp);
      allow read, update, delete: if signedIn() && resource.data.profileId == request.auth.uid;
    }

    match /userJourneys/{docId} {
      allow create: if signedIn() &&
        request.resource.data.profileId == request.auth.uid &&
        isValidSessionType(request.resource.data.choice) &&
        isValidLang(request.resource.data.lang) &&
        hasTimestamp(request.resource.data.timestamp);
      allow read, update, delete: if signedIn() && resource.data.profileId == request.auth.uid;
    }

    // Assessments: allow read/write for signed-in users in dev.
    match /userAbilityAssessments/{docId} {
      allow create: if signedIn() && request.resource.data.profileId == request.auth.uid;
      allow read, update, delete: if signedIn() && resource.data.profileId == request.auth.uid;
    }
    match /userIntentAssessments/{docId} {
      allow create: if signedIn() && request.resource.data.profileId == request.auth.uid;
      allow read, update, delete: if signedIn() && resource.data.profileId == request.auth.uid;
    }
    match /userKnowledgeAssessments/{docId} {
      allow create: if signedIn() && request.resource.data.profileId == request.auth.uid;
      allow read, update, delete: if signedIn() && resource.data.profileId == request.auth.uid;
    }
    match /userQuestSuggestions/{docId} {
      allow create: if signedIn() && request.resource.data.profileId == request.auth.uid;
      allow read, update, delete: if signedIn() && resource.data.profileId == request.auth.uid;
    }

    // Suggestions/inputs: enforce basic validation.
    match /userInterests/{doc} {
      allow create: if signedIn() &&
        isValidJournal(request.resource.data.text) &&
        isValidLang(request.resource.data.lang);
      allow read: if signedIn();
      allow update, delete: if false;
    }
    match /userSuggestions/{docId} {
      allow read, write: if signedIn();
    }
    match /usersInterests/{docId} {
      allow read, write: if signedIn();
    }
    match /usersinterests/{docId} {
      allow read, write: if signedIn();
    }

    // Public signups and unsubscribes can be open.
    match /signups/{doc} {
      allow create: if true;
    }
    match /emailUnsubscribes/{doc} {
      allow create: if true;
    }

    // Flow Studio admin area (dev only)
    match /adminConfig/{docId} {
      allow read, write: if isFlowStudioAdmin();
    }

    match /adminRoutes/{routeId} {
      allow read, write: if isFlowStudioAdmin();
    }

    match /adminFlows/{flowId} {
      allow read, write: if isFlowStudioAdmin();
    }

    match /copyOverrides/{screenId} {
      allow read: if true;
      allow write: if isFlowStudioAdmin();
    }

    function isAdmin() { return signedIn() && request.auth.token.admin == true; }

    // Insights: public read, admin-only writes
    match /insights/{theme} {
      // Allow everyone to read insights
      allow read: if true;
      // Writes require admin custom claim. Use backend or temporarily grant claim for seeding.
      allow create, update, delete: if isAdmin();
    }

    // Kuno practice attempts (dev): owner-only
    match /kunoAttempts/{docId} {
      allow create: if signedIn() && request.resource.data.profileId == request.auth.uid;
      allow read, update, delete: if signedIn() && resource.data.profileId == request.auth.uid;
    }

    // Kuno tests summary per profile
    match /cunoTests/{docId} {
      allow read: if isOwner(docId);
      allow create, update: if isOwner(docId);
    }

    // User recommendations: owner-only access
    match /userRecommendations/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create, update: if isOwner(userId);
      match /items/{recId} {
        allow read: if isOwner(userId) || isAdmin();
        allow create, update: if isOwner(userId);
      }
    }

    // Legacy CAT profile + history per user
    match /users/{userId}/catProfile/{docId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create, update: if isOwner(userId);
    }
    match /users/{userId}/catHistory/{docId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create, update: if isOwner(userId);
    }

    // Daily reset checkins: owner-only access
    match /userDailyCheckins/{docId} {
      allow read: if signedIn() && docId.matches(request.auth.uid + "_.*");
      allow create, update: if signedIn() && docId.matches(request.auth.uid + "_.*");
    }

    match /dailyPractice/{docId} {
      allow read: if signedIn() && resource.data.userId == request.auth.uid;
      allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if signedIn() && resource.data.userId == request.auth.uid;
    }

    // Telemetry sessions per user (used by admin debug + gating): owner-only
    match /userTelemetry/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create, update: if isOwner(userId);
      match /sessions/{sessionId} {
        allow read: if isOwner(userId) || isAdmin();
        allow create, update, delete: if isOwner(userId);
      }
    }

    function journalEntryOwnerMatches(data) {
      return data != null && (
        data.profileId == request.auth.uid ||
        (data.profileId == null && data.userId == request.auth.uid)
      );
    }
    function journalEntryIdMatches(entryId) {
      return signedIn() && entryId.matches(request.auth.uid + ".*");
    }
    function quizAttemptOwnerMatches(data) {
      return data != null && data.userId == request.auth.uid;
    }
    function quizAttemptIdMatches(attemptId) {
      return signedIn() && attemptId.matches(request.auth.uid + ".*");
    }

    // OmniKuno lesson journal entries (dev): owner-only pe profil
    match /lessonJournalEntries/{entryId} {
      allow read: if signedIn() && (
        resource.data == null ||
        journalEntryOwnerMatches(resource.data) ||
        journalEntryIdMatches(entryId)
      );
      allow create, update: if signedIn() && journalEntryOwnerMatches(request.resource.data);
      allow delete: if signedIn() && journalEntryOwnerMatches(resource.data);
    }
    match /userReplayData/{userId}/{document=**} {
      allow read, write: if isOwner(userId);
    }
    match /kunoQuizAttempts/{attemptId} {
      allow read: if signedIn() && (quizAttemptOwnerMatches(resource.data) || quizAttemptIdMatches(attemptId));
      allow create: if signedIn() && quizAttemptOwnerMatches(request.resource.data);
      allow update, delete: if signedIn() && quizAttemptOwnerMatches(resource.data);
    }

    // Fallback: deny everything else.
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
